I"<h3 id="迭代器模式">迭代器模式</h3>
<p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
(它提供一种方法访问一个容器对象中各个元素,而又不需暴露该对象的内部细节。)</p>
<h3 id="通用类图">通用类图</h3>
<p>抽象迭代器类，定义访问和遍历元素的接口
具体迭代器类，继承抽象迭代器类，实现接口方法，与具体容器类关联
抽象容器类，提供创建具体迭代器的接口
具体容器类，继承抽象容器类，实现方法，创建初容纳迭代器的对象，使用具体迭代器类</p>
<h3 id="通用源码">通用源码</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//抽象迭代器类
template &lt;typename T&gt;
class Iterator {
public:
    virtual T next() = 0;
    virtual booleam remove() = 0;
    virtual booleam hasxNext() = 0;
};
//具体迭代器类
template &lt;typename T&gt;
class ConcreteIterator: public Iterator {
public:
    ConcreteIterator(vector&lt;T&gt; v): vt(v) { }
    booleam hasxNext() {
        if(cursor == vt.size()) return false;
        else return true;
    }
    T next() {
        T t;
        if(hasxNext()) t = vt[cursor++];
        return t;
    }
    booleam remove() {
        vt.erase(vt.begin()+cursor++);
        return true;
    }

private:
    vector&lt;T&gt; vt;
    int cursor = 0;
};
//抽象容器类
template &lt;typename T&gt;
class Aggregate {
public:
    virtual void add(T) = 0;
    virtual void remove(T) = 0;
    virtual Iterator* iterator() = 0;
};
//具体容器类
template &lt;typename T&gt;
class ConcreteAggregate: public Aggregate {
public:
    void add(T t) {
        vt.insert(t);
    }
    void remove(T t) {
        auto iter = find(vt.begin(), vt.end(), t);
        vt.erase(iter);
    }
    Iterator* iterator() {
        return new ConcreteIterator(vt);
    }
private:
    vector&lt;T&gt; vt;
};
</code></pre></div></div>
<h3 id="应用">应用</h3>
<p>迭代器模式已经被各种容器已经内部实现了，这里讲述的是迭代器的内部大概是怎么实现的，它的思想是如何。
在一般的开发中，不需要自己再次实现迭代器模式</p>
<h3 id="示例代码">示例代码</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class IProject {
public:
    virtual string getProjectInfo() = 0;
};

class Project : public IProject {
public:
    Project(string s, int n, int c): name(s), num(n), cost(c) { }
    string getProjectInfo() {
        string info;
        info = "name: " + name;
        info += "\tnumber: " + to_string(num);
        info += "\tcost: " + to_string(cost);
        return info;
    }
private:
    string name;
    int num;
    int cost;
};

int main() {
    IProject* p = new Project("2048", 2, 5000);
    cout &lt;&lt; p-&gt;getProjectInfo() &lt;&lt; endl;
    return 0;
}
</code></pre></div></div>

:ET