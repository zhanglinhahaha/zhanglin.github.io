I";<h3 id="中介者模式">中介者模式</h3>
<p>Define an object that encapsulates how a set of objects interact.Mediator promotes loose coupling by keeping objects from referring to each other explicitly,and it lets you vary their interaction independently.
(用一个中介对象封装一系列的对象交互,中介者使各对象不需要显示地相互作用,从而使其耦合松散,而且可以独立地改变它们之间的交互。)</p>
<h3 id="通用类图">通用类图</h3>
<p>抽象中介类，定义统一的接口，用于各同事角色之间的通信
具体中介类，协调各同事角色实现写作行为，依赖于同事角色，继承抽象中介类
同事角色类，每个同事角色类都知道中介者角色，并通过中介者角色和其他同事通信</p>
<h3 id="通用源码">通用源码</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//抽象中介类
class Mediator {
protected:
    //定义同事类
    ConcreteColleague1 c1;
    ConcreteColleague2 c2;
public:
    //通过set和get注入同事类
    ConcreteColleague1 getC1() {return c1;}
    void setC1(ConcreteColleague1&amp; c) {c1 = c;}
    ConcreteColleague2 getC2() {return c2;}
    void setC2(ConcreteColleague2&amp; c) {c2 = c;}
    //中介者模式的业务逻辑
    virtual void doSomething1() = 0;
    virtual void doSomething2() = 0;
};
//具体中介者类
class ConcreteMediator : public Mediator {
    virtual void doSomething1() {
        //调用同事类的方法
        c1.selfMethod1();
        c2.selfMethod2();
    }
    virtual void doSomething2() {
        c1.selfMethod1();
        c2.selfMethod2();
    }
};
//抽象同事类
class Colleague {
protected:
    Mediator mediator;
public:
    Colleague(Mediator m) { mediator = m;}
};
//具体同事类
class ConcreteColleague1 : public Colleague {
public:
    //构造函数传递中介者
    ConcreteColleague1(Mediator m) : Colleague(m) { }
    //自有方法self-method
    void selfMethod1() {
        //业务逻辑
    }
    //依赖方法 dep-method
    void depMethod1() {
        //业务逻辑
        //委托中介者处理
        mediator.doSomething1();
    }
};
class ConcreteColleague2 : public Colleague {
public:
    //构造函数传递中介者
    ConcreteColleague2(Mediator m) : Colleague(m) { }
    //自有方法self-method
    void selfMethod2() {
        //业务逻辑
    }
    //依赖方法 dep-method
    void depMethod2() {
        //业务逻辑
        //委托中介者处理
        mediator.doSomething2();
    }
};
</code></pre></div></div>
<h3 id="优点">优点</h3>
<p>减少类间依赖，降低类间耦合</p>
<h3 id="缺点">缺点</h3>
<p>中介者会膨胀，且逻辑复杂</p>
<h3 id="使用场景">使用场景</h3>
<p>适用于多个对象之间紧密耦合的情况，在类图中出现了蜘蛛网状结构，可以考虑使用中介者模式，使得蜘蛛网状结构变成星型结构。
N(N&gt;2)个对象之间产生了相互的依赖关系
多个对象有依赖关系，但是依赖的行为尚不确定或者有发生改变的可能
产品开发，例如MVC框架</p>
<h3 id="实际应用">实际应用</h3>
<p>机场调度中心；
MVC框架；
媒介网关；
中介服务；</p>
<h3 id="示例代码">示例代码</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

using namespace std;

class Purchase {
public:
    void buyIBMcomputer(int);
    void refuseBuyIBM();
};

class Sale {
public:
    void sellIBMComputer(int);
    int getSaleStatus() {
        srand((int)time(0));
        return rand()%100;
    }
    void offSale();
};

class Stock {
private:
    static int COMPUTER_NUMBER;
public:
    void increase(int);
    void decrease(int);
    int getStockNumber() {return COMPUTER_NUMBER;}
    void clearStock();
};

int Stock::COMPUTER_NUMBER = 100;

void Purchase::buyIBMcomputer(int number) {
    Stock stock; Sale sale;
    int saleStatus = sale.getSaleStatus();
    if(saleStatus &gt; 80) {
        cout &lt;&lt; "Purchase IBM computer: " &lt;&lt; number &lt;&lt; endl;
        stock.increase(number);
    }else {
        int buyNumber = number / 2;
        cout &lt;&lt; "Purchase IBM computer: " &lt;&lt; number &lt;&lt; endl;
        stock.increase(buyNumber);
    }
}

void Purchase::refuseBuyIBM() {
    cout &lt;&lt; "No more need to purchase IBM computer" &lt;&lt; endl;
}

void Stock::increase(int number) {
    COMPUTER_NUMBER += number;
    cout &lt;&lt; "Stock COMPUTER_NUMBER: " &lt;&lt; COMPUTER_NUMBER &lt;&lt; endl;
}

void Stock::decrease(int number) {
    COMPUTER_NUMBER -= number;
    cout &lt;&lt; "Stock COMPUTER_NUMBER: " &lt;&lt; COMPUTER_NUMBER &lt;&lt; endl;
}

void Stock::clearStock() {
    Purchase purchase; Sale sale;
    cout &lt;&lt; "Clear stock number: " &lt;&lt; COMPUTER_NUMBER &lt;&lt; endl;
    sale.offSale();
    purchase.refuseBuyIBM();
}

void Sale::sellIBMComputer(int number) {
    Stock stock; Purchase purchase;
    if(stock.getStockNumber() &lt; number) purchase.buyIBMcomputer(number);
    cout &lt;&lt; "Sell IBM computer number: " &lt;&lt; number &lt;&lt; endl;
    stock.decrease(number);
}

void Sale::offSale() {
    Stock stock;
    cout &lt;&lt; "Sell IBM computer discount number: " &lt;&lt; stock.getStockNumber() &lt;&lt; endl;
    stock.decrease(stock.getStockNumber());
}

int main() {
    Purchase purchase; Stock stock; Sale sale;
    purchase.buyIBMcomputer(100);
    sale.sellIBMComputer(10);
    stock.clearStock();
    return 0;
}
</code></pre></div></div>

:ET