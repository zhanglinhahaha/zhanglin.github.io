I"Y
<h3 id="观察者模式">观察者模式</h3>
<p>也叫做发布订阅模式(Publish/subscribe)
Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.
(定义对象间一种一对多的依赖关系,使得每当一个对象改变状态,则所有依赖于它的对象都会得到通知并被自动更新。)</p>
<h3 id="通用类图">通用类图</h3>
<p>被观察者抽象类
定义被观察者必须实现的职责，能够动态的增加、取消观察者，完成被观察者必须实现的职责：管理观察者并通知观察者
被观察者具体类
继承其抽象类，定义自己的业务逻辑，定义对哪些事件进行通知
观察者抽象类
观察者接收到消息后，对信息进行处理
观察者具体类
继承其抽象类，每个观察者收到信息后的处理不同，实现各自的逻辑</p>
<h3 id="通用源码">通用源码</h3>
<p>//被观察者抽象类
class Subject {
public:
    //增加观察者
    void addObserver(Observer <em>ob) {
        sob.insert(ob);
    }
    //删除观察者
    void deleteObserver(Observer *ob) {
        sob.erase(ob);
    }
    //通知观察者
    void notifyObservers() {
        for(auto ob : sob) ob-&gt;updated();
    }
private:
    //定义观察数组
    set&lt;Observer</em>&gt; sob;
};
//被观察者具体类
class ConcreteSubject : public Subject {
public:
    void doSomething() {
        //do something
        Subject::notifyObservers();
    }
};
//观察者抽象类
class Observer {
public:
    //更新方法
    virtual void updated() = 0;
};
//观察者具体类
class ConcreteObserver : public Observer {
public:
    void updated() override {
        //收到消息，逻辑处理
    }
};</p>
<h3 id="优点">优点</h3>
<p>观察者和被观察者之间是抽象耦合，观察者和被观察者都非常容易扩展
建立一套触发机制，一个事物的改变引起其他事物的变化</p>
<h3 id="缺点">缺点</h3>
<p>需要考虑开发效率和运行效率</p>
<h3 id="使用场景">使用场景</h3>
<p>关联行为场景
事件多级触发场景
跨系统的消息交换场景</p>
<h3 id="注意事项">注意事项</h3>
<p>广播链的问题
当一个对象既是观察者又是被观察者，会导致逻辑比较复杂，可维护性变差
异步处理问题
当观察者非常多的时候，异步处理，需要考虑线程安全和队列的问题</p>
<h3 id="示例代码">示例代码</h3>
<p>```
#include <iostream>
#include <string>
#include <thread>
#include <unistd.h>
#include <set></set></unistd.h></thread></string></iostream></p>
:ET