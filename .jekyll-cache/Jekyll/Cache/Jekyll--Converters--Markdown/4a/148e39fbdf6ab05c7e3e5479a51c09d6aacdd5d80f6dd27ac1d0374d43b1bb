I"H<h3 id="享元模式">享元模式</h3>
<p>Use sharing to support large numbers of fine-grained objects efficiently.
(使用共享对象可有效地支持大量的细粒度的对象。)</p>
<h3 id="对象的内部状态和外部状态">对象的内部状态和外部状态</h3>
<p>内部状态：对象可共享出来的信息，存储在对象内部并且不会随环境改变而改变，可以作为一个对象的动态附加信息不必直接储存在某个具体对象中，属于可以共享的部分
外部状态：是对象得以依赖的一个标记，随环境改变而改变，不可以共享的状态。它是一批对象的统一标识，是唯一的一个索引值。</p>
<h3 id="通用类图">通用类图</h3>
<p>抽象享元类
是一个产品的抽象类，同时定义出对象的外部状态和内部状态
具体享元类
继承抽象享元类，实现方法，该类中内部状态处理应该与环境无关，不应该出现一个操作即改变了内部状态，又改变了外部状态。
不可共享的享元类
继承抽象享元类，不存在外部状态或安全要求不能够使用共享技术的对象，该对象一般不会出现在享元工厂类中
享元工厂类
构造一个池容器，提供从池中获得对象的方法</p>
<h3 id="通用代码">通用代码</h3>
<p>//抽象享元类
class Flyweight {
public:
    //享元角色必须接受外部状态
    Flyweight(string e): ex(e) { }
    //业务操作
    virtual void ope() = 0;
    //内部状态的getset
    string getIntrinsic() { return in; }
    void setIntrinsic(string s) { in = s; }
private:
    //内部状态
    string in;
protected:
    //外部状态
    string ex;
};
//具体享元类
class ConcreteFlyweight : public Flyweight {
public:
    //接受外部状态
    ConcreteFlyweight(string e): Flyweight(e) { }
    void ope() override {
        //业务逻辑
    }
};
//享元工厂类
class FlyweightFactory {
public:
    //享元工厂返回对象
    static Flyweight getFlyweight(string e) {
        Flyweight <em>f = nullptr;
        if(pool.find(e) == pool.end()) {
            f = new ConcreteFlyweight(e);
            pool[e] = f;
        }else {
            f = pool[e];
        }
        return *f;
    }
private:
    //定义一个池容器
    map&lt;string, Flyweight</em>&gt; pool;
};</p>
<h3 id="优点">优点</h3>
<p>减少程序创建的对象
降低内存占用
增强性能</p>
<h3 id="缺点">缺点</h3>
<p>提高系统复杂性
需要分离对象的外部和内部对象，外部状态不随内部状态改变而改变</p>
<h3 id="使用场景">使用场景</h3>
<p>系统中存在大量的相似对象
细粒度的对象具备较接近的外部状态
需要缓冲池</p>
<h3 id="示例代码">示例代码</h3>
<h3 id="示例代码-1">示例代码</h3>
<p>```
#include <iostream>
#include <string>
#include &lt;map&gt;</string></iostream></p>
:ET